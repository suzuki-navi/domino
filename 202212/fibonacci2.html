<!DOCTYPE html>
<html>
<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
<meta charset="utf-8"/>
<title>フィボナッチ数列 その2 | セルオートマトンによるCPU作成</title>
<meta property="og:title" content="フィボナッチ数列 その2"/>
<meta property="og:type" content="article"/>
<meta property="og:url" content="https://suzuki-navi.github.io/domino/202212/fibonacci2.html"/>
<meta property="og:image" content="https://suzuki-navi.github.io/domino/202212/fibonacci2_og.png"/>
<meta property="og:description" content=""/>
<meta property="og:site_name" content="suzuki-naviのセルオートマトンによるCPU作成"/>
<link rel="stylesheet" href="../domino.css"></link>
<link rel="stylesheet" href="../demo.css"></link>
</head>
<body>
  <section>
    <h1>フィボナッチ数列 その2</h1>
    <p>この記事は<a href="./">セルオートマトンによるCPU作成</a>連載記事の18本目です。(2023/01/24)</p>

    <p>今回は<a href="fibonacci1.html">前回のフィボナッチ数列の回路</a>を改良してきます。</p>
    <h2>ver.2</h2>
    <p>ver.2では、オーバーフローしたときに1にリセットするようにしました。<p>
    <p>加算器の最上位ビットの繰り上がりフラグの出力を拾い、繰り上がりがあったら加算結果が流れるのをブロックして、代わりに1という値を出力するようにします。また、その繰り上がりフラグが立っているときには、シグナルを2つのレジスタに流すようにして、レジスタ2つとも1にリセットするようにします。</p>
    <p>フラグが立っているときには加算結果をブロックして1を出力の回路</p>
    <p><img src="fibonacci2-2-1.png"></p>
    <p>フラグが立っているときには次のシグナルがどちらのレジスタ宛であっても両方のレジスタにシグナルを流すように制御する回路</p>
    <p><img src="fibonacci2-2-2.png"></p>
    <p>回路が大きいので別ページにしました。以下のリンクから実際に試すことができます。</p>
    <p><a href="fibonacci2-2.html">ver.2 の回路</a></p>
    <p>これでオーバーフロー時にリセットという当初要件を満たしていますが、ここから回路を改善していきます。これまでの場当たり的な回路を汎用的な再利用しやすい形に変えていきます。リファクタリングをするようなものです。</p>
    <h2>ver.3</h2>
    <p>次のバージョンでは回路の作り方の考え方を変えており、次の処理を順番に実行するようにしています。動作開始時は1から始まります。</p>
    <table>
      <tr><td>0</td><td>レジスタAとBにシグナルを流す</td></tr>
      <tr><td>1</td><td>フラグが立っているときには0にジャンプ</td></tr>
      <tr><td>2</td><td>レジスタAにシグナルを流す</td></tr>
      <tr><td>3</td><td>フラグが立っているときには0にジャンプ</td></tr>
      <tr><td>4</td><td>レジスタBにシグナルを流す</td></tr>
      <tr><td>5</td><td>1にジャンプ</td></tr>
    </table>
    <p>回路一番上のループ回路でシグナルが実際の処理にそって流れています。1から5まで進んで、また1に戻るのをループ回路で繰り返しています。ただし、1または3ではフラグが立っているときには次に進むのではなく、0に移動するようになっています。</p>
    <p><img src="fibonacci2-3-1.png"></p>
    <p><a href="fibonacci2-3.html">ver.3 の回路</a></p>
    <h2>ver.4</h2>
    <p>先ほどのバージョンではシグナルの移動に応じて処理内容が決まりましたが、次のバージョンではカウンタを1ずつ増やし、カウンタの値に応じて処理内容が決まるようにします。</p>
    <p>カウンタは初期状態では1とします。</p>
    <table>
      <tr><th>カウンタの値</th><th>処理内容</th><th>次のカウンタ値</th></tr>
      <tr><td>0</td><td>レジスタAとBにシグナルを流す</td><td>1増やす (1に進む)</td></tr>
      <tr><td>1</td><td>レジスタAにシグナルを流す</td><td>1増やす (2に進む)</td></tr>
      <tr><td>2</td><td>レジスタBにシグナルを流す</td><td>1にセット (1に戻る)</td></tr>
      <tr><td>(上記によらず)繰り上がりフラグが立っているとき</td><td></td><td>0にセット (0に戻る)</td></tr>
    </table>
    <p>カウンタの値が最大で2なので、カウンタは2ビットです。カウンタは以前作成した<a href="counter2.html">値の設定が可能なカウンタ</a>を使っています。フラグが立っているときはカウントアップせずに0にセットするようになっています。</p>
    <p><img src="fibonacci2-4-1.png"></p>
    <p><a href="fibonacci2-4.html">ver.4 の回路</a></p>
    <h2>ver.5</h2>
    <p>ver.5では、カウンタをセットする処理を独立した処理にしています。</p>
    <table>
      <tr><th>カウンタの値</th><th>処理内容</th><th>次のカウンタ値</th></tr>
      <tr><td>0</td><td>レジスタAとBにシグナルを流す</td><td>1増やす</td></tr>
      <tr><td>1</td><td>繰り上がりフラグが立っていればカウンタを0にセット</td><td>(フラグが立っていなければ) 1増やす</td></tr>
      <tr><td>2</td><td>レジスタAにシグナルを流す</td><td>1増やす</td></tr>
      <tr><td>3</td><td>繰り上がりフラグが立っていればカウンタを0にセット</td><td>(フラグが立っていなければ) 1増やす</td></tr>
      <tr><td>4</td><td>レジスタBにシグナルを流す</td><td>1増やす</td></tr>
      <tr><td>5</td><td>カウンタを1にセット</td><td>-</td></tr>
    </table>
    <p>今回の回路ではカウンタが2ビットでは足りないので3ビットに増やします。</p>
    <p><img src="fibonacci2-5-1.png"></p>
    <p><a href="fibonacci2-5.html">ver.5 の回路</a></p>
    <p>お分かりかと思いますが、この回路でカウンタと言っているものは、CPUでのプログラムカウンタになります。プログラムカウンタは現在実行している命令の場所を示し、命令を実行するごとに1ずつ値が増えていきます。条件分岐などがあるとプログラムカウンタが特定の値にセットされ、命令がジャンプします。</p>
    <h2>ver.6</h2>
    <p>いままではディスプレイに出力する値は加算器と直結していました。そのためディスプレイに表示する内容に自由度がありませんでした。そこで、ディスプレイの手前に8ビットレジスタを設置します。レジスタCとしておきます。</p>
    <p><img src="fibonacci2-6-1.png"></p>
    <table>
      <tr><th>カウンタの値</th><th>処理内容</th></tr>
      <tr><td>0</td><td>レジスタAとBにシグナルを流す</td></tr>
      <tr><td>1</td><td>繰り上がりフラグが立っていればカウンタを0にセット</td></tr>
      <tr><td>2</td><td>レジスタAとCにシグナルを流す</td></tr>
      <tr><td>3</td><td>繰り上がりフラグが立っていればカウンタを0にセット</td></tr>
      <tr><td>4</td><td>レジスタBとCにシグナルを流す</td></tr>
      <tr><td>5</td><td>カウンタを1にセット</td></tr>
    </table>
    <p><a href="fibonacci2-6.html">ver.6 の回路</a></p>
    <h2>ver.7</h2>
    <p>繰り上がりフラグが立っていたら加算結果をブロックして1という値に上書きする処理をアドホックな回路で実現していたので、ここを汎用的な処理にできるように書き換えます。</p>
    <p>加算結果と1のどちらを採用するのかをカウンタからの信号で制御するようにします。カウンタからの信号をここでは出力制御という言い方にします。オーバーフロー発生時は加算結果を出力せずに1を出力するために、出力制御0のシグナルを流し、続けて出力制御1のシグナルを流します。</p>
    <table>
      <tr><td>出力制御0</td><td>なにも出力しない</td></tr>
      <tr><td>出力制御1</td><td>1を出力</td></tr>
      <tr><td>出力制御2</td><td>加算結果を出力</td></tr>
    </table>
    <p><img src="fibonacci2-7-1.png"></p>
    <p>処理の流れは次のようになります。最初にジャンプ命令を置いたので、カウンタは初期状態では0にできます。</p>
    <table>
      <tr><th>カウンタの値</th><th>処理内容</th></tr>
      <tr><td>0</td><td>カウンタを4にセット</td></tr>
      <tr><td>1</td><td>出力制御0と1にシグナルを流す</td></tr>
      <tr><td>2</td><td>レジスタAとBとCにシグナルを流す</td></tr>
      <tr><td>3</td><td>出力制御0と2にシグナルを流す</td></tr>
      <tr><td>4</td><td>繰り上がりフラグが立っていればカウンタを1にセット</td></tr>
      <tr><td>5</td><td>レジスタAとCにシグナルを流す</td></tr>
      <tr><td>6</td><td>繰り上がりフラグが立っていればカウンタを1にセット</td></tr>
      <tr><td>7</td><td>レジスタBとCにシグナルを流す</td></tr>
      <tr><td>8</td><td>カウンタを4にセット</td></tr>
    </table>
    <p><a href="fibonacci2-7.html">ver.7 の回路</a></p>
    <h2>ver.8</h2>
    <p>今回の記事の最後のバージョンです。回路の上のほうにあった制御回路を大幅に作り直しました。</p>
    <p>条件判定をして特定の場所にジャンプする命令を3つの命令に分割しました。フラグレジスタへのロード、条件判定、ジャンプの3命令です。条件判定はいままで繰り上がりフラグと直結していましたが、汎用化するために間にフラグレジスタを入れ、フラグレジスタへのロードという命令を追加します。いまの段階ではまだ意味のない命令です。条件判定の命令では、フラグレジスタの値によって次の命令をスキップします。その次にジャンプする命令を置きます。これで条件によってジャンプするか、次に進むかの分岐ができます。</p>
    <p>制御回路にあるプログラムカウンタは3ビットから5ビットに増やしています。4ビットで足りるのですが作りすぎました。汎用化できるように余裕を持った作りにしたので、使われていない線がいっぱいできてしまいました。</p>
    <p>これまでのバージョンで一番上にあった周期的なシグナルを提供するループ回路もこの制御回路の中に埋め込まれています。命令のスキップを実装するためにver.3での考え方が部分的に復活し、スキップの場合にシグナルの流れが分岐するようになっています。</p>
    <p><img src="fibonacci2-8-1.png"></p>
    <p>処理の流れは次のようになります。</p>
    <table>
      <tr><th>カウンタの値</th><th>処理内容</th></tr>
      <tr><td>0</td><td>カウンタを7にセット</td></tr>
      <tr><td>1</td><td>出力制御0と1にシグナルを流す</td></tr>
      <tr><td>2</td><td>レジスタAとBとCにシグナルを流す</td></tr>
      <tr><td>3</td><td>出力制御0と2にシグナルを流す</td></tr>
      <tr><td>4</td><td>繰り上がりフラグをフラグレジスタにロード</td></tr>
      <tr><td>5</td><td>フラグレジスタが立ってなければ次をスキップ</td></tr>
      <tr><td>6</td><td>カウンタを1にセット</td></tr>
      <tr><td>7</td><td>レジスタAとCにシグナルを流す</td></tr>
      <tr><td>8</td><td>繰り上がりフラグをフラグレジスタにロード</td></tr>
      <tr><td>9</td><td>フラグレジスタが立ってなければ次をスキップ</td></tr>
      <tr><td>10</td><td>カウンタを1にセット</td></tr>
      <tr><td>11</td><td>レジスタBとCにシグナルを流す</td></tr>
      <tr><td>12</td><td>カウンタを4にセット</td></tr>
    </table>
    <p><a href="fibonacci2-8.html">ver.8 の回路</a></p>
    <!--
    <p>ここまで回路を少しずつ汎用化してきましたが、処理内容が制御回路の中に書き込まれていました。これを外に出していきたいと思います。処理内容をメモリに入れて、メモリを順番に読み出しながら実行するようにしていきます。</p>
    -->
  </section>
  <section>
    <p><a href="./">連載目次に戻る</a></p>
  </section>
</body>
</body>
</html>
